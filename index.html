<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><title>Defender</title><style>
  body { image-rendering:pixelated; overflow:hidden; touch-action:none; position:fixed; width:100vw; height:100vh; margin:0; border:0; padding:0; background-color:#000; color:#0ff; font-family:monospace,sans-serif,arial,helvetica; }
  p { position:absolute; display:inline-block; width:calc(1ch - 1px); height:calc(1ch - 1px); margin:0; border:0;  padding:0; }
  div { position:absolute; }
  canvas { position:absolute; margin:0; border:0; padding:0; }
</style></head><body><canvas><script>
const ø=undefined;
const $ = document.querySelector.bind(document);
const $$ = document.querySelectorAll.bind(document);
const PI=Math.PI;
const PI2=PI*2;
window.keys=Object.keys.bind(Object);
window.requestIdleCallback ||= (f)=>f();
String.prototype.atoi = function(){return parseInt(this);}
String.prototype.atof = function(){return parseFloat(this);}
Number.prototype.floor = function (){return Math.floor(this);}
Number.prototype.int = function(){return this|0;}
Number.prototype.abs = function(){return Math.abs(this);}
Number.prototype.frac= function(){return this.abs()%1;}
Number.prototype.mod = function (d){return this-d*(this/d).floor();}
Number.prototype.cos = function(){return Math.cos(this);}
Number.prototype.sin = function(){return Math.sin(this);}
const jiffies=Date.now;
const rnd=i=>i*Math.random()|0;
const min=Math.min.bind(Math);
const max=Math.max.bind(Math);
const l=(v)=>(console.log(v),v);
var Ok = (o, self=(f)=>(o=f(o)||o, self))=>(self(_=>{self.unwrap=_=>o})) // Monadical framework
const exit = (msg="the end")=>{throw msg}

const body = $("body");
const canvas = $('canvas');
const c2d = canvas.getContext('2d');

////

function tick (v, db) {
  body.insertAdjacentHTML("beforeend", `<p id=db style="width:100%">0`);
  db=$("#db");
  (tick = (v)=>db.innerText=v||db.innerText.atoi()+1)(v);
}

////

var snd = ((filenames)=>{
  const wac = new AudioContext();
  const dest = wac.destination;
  const sched = {}
  const self = {wac, dest};

  self.slurp = (fn)=>{
    fetch(fn)
      .then(resp=>resp.arrayBuffer())
      .then(ary=>wac.decodeAudioData(ary))
      .then(aud=>self[fn=fn.split('.')[0]]=aud)
      .then(aud=>sched[fn]?.(), delete sched[fn]);
    return self;
  }

  const source = (name, a={}, dst=dest, delay=0)=>(
    a.buffer = self[name],
    a = new AudioBufferSourceNode(wac, a),
    a.connect(dst),
    a.start(delay),
    a
  );

  self.source = (n, dst, delay) => source(n, {}, dst, delay);
  self.sourceLoop = (n, dst, delay) => source(n, {loop:true}, dst, delay);

  self.oscillator = (type, frequency, map, dst=dest, at)=>{ // sine square sawtooth triangle custom.
    const n = new OscillatorNode(wac, {type, frequency});
    n.connect(dst);
    n.start(at);
    map?.(n); // maybe fiddle with the node
    return n;
  };

  self.oscillatorSine     = (f, map, dst, at)=>self.oscillator("sine", f, map, dst, at);
  self.oscillatorSquare   = (f, map, dst, at)=>self.oscillator("square", f, map, dst, at);
  self.oscillatorSawtooth = (f, map, dst, at)=>self.oscillator("sawtooth", f, map, dst, at);

  self.gain = (g, map, dst=dest)=>(
    g = new GainNode(wac, g==undefined?undefined:{gain:g}),
    map?.(g), // maybe fiddle with the node
    g.connect(dst),
    g
  );

  self.lowpass = (q, f, map, dst=dest)=>(
    f = new BiquadFilterNode(wac, {type:"lowpass", Q:q, frequency:f}),
    map?.(f, wac.currentTime),
    f.connect(dst),
    f
  );

  self.play = (n, t=0)=>self.source(n, dest, wac.currentTime+t);

  self.map = (n,f)=>self[n]
    ? self[n].getChannelData(0).forEach(f)
    : sched[n] = ()=>self.map(n,f);

  self.notes = function (s, onEnded, key=0, at=snd.wac.currentTime, k,d,to){
    let tempo = 120;
    const started=at, release=.2;
    [...s.matchAll(/([<>v^]*)([a-gACDFGrt])([0-9]?)([0-9]?)([0-9]?)/g)].forEach(a=>{
      if ('t'==a[2]) { tempo = (a[3]+a[4]+a[5]).atoi() || 120; return; }
      to = at+15*(a[3].atoi() || 4)*(a[4].atoi() || 1)/tempo; // 1/16th base note
      if ('r'==a[2]) {
        self.oscillatorSine(0, o=>o.stop(to));
      } else {
        key += (12*a[1].length * {'v':-1,'<':-1, '^':1,'>':1}[a[1][0]]||0);
        k = {'a':0,'A':1,'b':2,'c':3,'C':4,'d':5,'D':6,'e':7,'f':8,'F':9,'g':10,'G':11}[a[2]];
        7 <= (d = (k-key).mod(12)) && (d = -((key-k).mod(12)));
        self.oscillatorSawtooth(110*2**((key+=d)/12),
          (o)=>o.stop(to+release),
          self.gain(1, (g)=>(
            g.gain.setValueAtTime(0.2, at),
            g.gain.linearRampToValueAtTime(0, to+release))),
          at);
      }
      at = to;
    });
    onEnded && self.oscillatorSine(0, o=>o.stop(to)).addEventListener("ended", onEnded);
    return at-started;
  };

  filenames.forEach(self.slurp);

  self["noise"] = Ok(wac.createBuffer(1, 44100, wac.sampleRate))
    ((aud)=>{aud.copyToChannel(new Float32Array(44100).map(()=>2*Math.random()-1), 0);})
    .unwrap();

  return self;

})(["ignignokt.wav", "trump.wav", "nasi.wav"]);


snd.map("trump", (s,i,a)=>a[i]=.5*s);


sfx = async()=>{
  // background sirens
  [[400, 1, 180],
   [300, .9, 190]]
  .forEach(([freq, sweep, depth])=>
    snd.oscillatorSine(freq,
      (osc)=>snd.oscillatorSine(sweep, ø, snd.gain(depth, ø, osc.detune)),
      snd.gain(.05)));

  // background engines
  snd.sourceLoop("noise", snd.lowpass(0, 200));

  tune.next();
};

const soundExplode = ()=>
  snd.source("noise",
    snd.gain(.2, ø,
      snd.lowpass(.001, 2000, (lp, now)=>lp.frequency.linearRampToValueAtTime(0, now+.8))));

// level start melody
tune = function* () {
  const song=[
    "t140^c1 c1 c2 e2 d2 f2 e1 f1 g1 e1 d2 f2 e1 f1 g1 e1 f1 g1 a1 b1 c2 b2 c4",
    "t190 c6 b2 c6  b2 c2 g2 c2 e2  g8",
    "t220 ^c2 a2 fff2g2a2A2 ccca",
    "t140^^aA2vA2^g2A2c2vc2^a2A2vA2^g2A2d2D2vD2^d2c2A",
    "t180 ^^a3a1Favd8 eF8 a3a1FaC8 de8",
    "t300^cdef7cD9A8C8Gc82^f4f2f2g4fAf8c2e2f4",
    "t180^^f1g1G1c1f9Gg2D9Gg2vC9^Gg2vG8",
    "a a a  f3 ^c1 a  f3 ^c1 a24",
    "^e e e  f3 c1 a  f3 ^c1 a24",
    "^a va ^a  G2 g2 g1 F1 g5  d2 6g7",
    "^f2 e2 f1 e1 f  c2 f  vf3 ^c1 a  f3 ^c1 a",
    "t240 a2 a2 a2 ^d F  va2 a2 a2 d F  d2 d2 C2 C2 b2 b2 a",
    "a2 a2 F1 a1 b2 b  a1 b1 c2 c  b1 c1 b2 g2 g2 a",
    "t140 ^g2 g2 g2 g2 vc2 c2 a2 ^e2 f2 e2 c c2 c2 c2 e2 f2 e2 d2 d2 c2 c2 g2 ^e2 f2 e2 d",
  ];
  while (1) for (notes of song) { snd.notes(notes); yield; }
}();

////

var bytes = [];
var sprites = {};

var renderSprite = (id) => {
  const z = canvas.pixelSize;
  const zz = canvas.pixelWidth;
  const s = sprites[id]
  if (!s) { return; }
  const {x,y,w,h,pixels,center} = s;
  //const k=(mouse.x-x-center.x).abs()<4 && (mouse.y-y-center.y).abs()<4;

  if (!s.image) {
    s.image = new Image(w*z, h*z);

    const cnvs = document.createElement('canvas');
    cnvs.width = s.image.width;
    cnvs.height = s.image.height;

    const ctx = cnvs.getContext('2d');
    pixels[0]
      .forEach((row,yy)=>row
        .forEach((c,xx)=>(ctx.fillStyle=c) && ctx.fillRect(xx*z, yy*z, zz, zz)));

    s.image.src = cnvs.toDataURL('image/png');
  }

  c2d.drawImage(s.image, x*z|0, y*z|0);

  //pixels[0] // plot each pixel directly ++expensive;
  //  .forEach((row,yy)=>row
  //    .forEach((c,xx)=>c&&box(xx+x, yy+y, /*k||(xx==center.x&&yy==center.y)?'#fff':*/c)));
}

var renderSpriteMod = (id, actor) => {
  const {x,y,pixels} = sprites[id];
  var i=0;
  pixels[0]
    .forEach((row,yy)=>row
      .forEach((c,xx)=>c&&box(xx+x+(i+=.5).cos()*actor.exploding|0, yy+y+i.sin()*actor.exploding|0, c)));
  actor.exploding++;
}

var renderSprites = (ids) => {
  (ids||keys(sprites)).forEach(renderSprite)
}

const makeSprite2 = (id, x, y, pixels, colors)=>{
  colors = Object.fromEntries([...colors.matchAll(/(.)(...) ?/g)].map(e=>e.slice(1)));
  var w=0, h=0, xs=0, ys=0, ps=0;
  pixels = pixels.map((pixels,i)=>pixels
    .map((row,y)=>[...row]
      .map((ch,x)=>(ps++,xs+=x,ys+=y,colors[ch]
        ? ( h<y&&(h=y), w<x&&(w=x), '#'+colors[ch])
        : undefined))));
  return sprites[id] = {x, y, w:w+1, h:h+1, hidden:false, pixels, center:{x:xs/ps|0, y:ys/ps|0}};
}

const makeSprite3 = (id, w, h, data)=>{
  var xs=0, ys=0, ps=0;
  pixels = [[...Array(h)].map((_,y)=>
    [...Array(w)].map((_,x)=>{
      const r = data[(x+y*w)*4+0];
      const g = data[(x+y*w)*4+1];
      const b = data[(x+y*w)*4+2];
      ps++; xs+=x;  ys+=y;
      return !r && !g && !b
        ? undefined
        : '#' + r.toString(16).padStart(2,0) + g.toString(16).padStart(2,0) + b.toString(16).padStart(2,0);
    }))];

  return sprites[id] = {x:0, y:0, w, h, hidden:false, pixels, center:{x:xs/ps|0, y:ys/ps|0}};
}

const makeSprite = (id, x, y, pixels, colors)=>{
  colors = Object.fromEntries([...colors.matchAll(/(.)(...) ?/g)].map(e=>e.slice(1)));

  body.insertAdjacentHTML("afterbegin",
  `<div ${id?"id="+id:""} style="top:${y}%;left:${x}%">`
  + pixels.map((pixels,i)=>
      `<div ${i?"hidden":""}>${
        pixels.flatMap((row,y)=>[...row].map((ch,x)=>
          ch.trim() && `<p style="left:${x}ch;top:${y}ch;background-color:#${colors[ch]||"fff"}">`))
        .join('')
      }</div>`
    ).join(''));

  return body.firstChild;
}

async function rp1New (v=0) {
  [makeSprite,makeSprite2][v]("rp1", 100, 45, [
  ["**  *** *** **  * *   *** *   *** * * *** **     *    *",
   "* * *   * * * * * *   * * *   * * * * *   * *   **    *",
   "**  **  *** * *  *    *** *   ***  *  **  **     *    *",
   "* * *   * * * *  *    *   *   * *  *  *   * *    *     ",
   "* * *** * * **   *    *   *** * *  *  *** * *   ***   *"],
  ], "*eee");
}

async function pbNew () {
  const e = makeSprite("pb", 50, 50, [
  [
   "  ############  ",
   " #************# ",
   "#**************#",
   "#****@@********#",
   "#****@.@*******#",
   "#****@..@******#",
   "#****@...@*****#",
   "#****@....@****#",
   "#****@.....@***#",
   "#****@....@****#",
   "#****@...@*****#",
   "#****@..@******#",
   "#****@.@*******#",
   "#****@@********#",
   "#**************#",
   " #************# ",
   "  ############  ",
  ],
  [
   "  ############  ",
   " #************# ",
   "#**************#",
   "#***@@@**@@@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@.@**@.@***#",
   "#***@@@**@@@***#",
   "#**************#",
   " #************# ",
   "  ############  ",
  ],
  ], "*057 #035 @ccc .fff");
  e.style.zIndex=1;
}

async function playerNew (s=0) {
  [makeSprite,makeSprite2][s]("p1", 0, 50, [
  ["  **",
   " ****            ******* ",
   "r*****              rrrw ",
   " *mm*****byr       ryyyrw",
   "r*mmmm*******wg ********wg",
   "  mmm*wg           ryyyrw",
   "                    rrrw ",
   "                 ******* "],
  ["  **",
   " ****                    ",
   "y*****          *******w ",
   " *mm*****byr       ryyyrw",
   "y*mmmm*******wg    ryyyrwg",
   "  mmm*wg        ********w",
   "                    rrrw ",
   "                         "],
  ["  **",
   " ****                    ",
   "w*****              rrrw ",
   " *mm*****byr    ********w",
   "w*mmmm*******wg    ryyyrwg",
   "  mmm*wg            rrrrw",
   "                 ******w ",
   "                         "]
  ], '*888 ydd0 b00d rd00 md0d wddd g0d0');
}

async function trumpNew (s=0) {
  const e = [makeSprite,makeSprite2][s](s?"trump":undefined, 50, 50,[
  ["         hhhhhhhhhh ",
   "      hhhhhhhhhhh   ",
   "    hhhhhhhhhhhhh   ",
   "   hhhhhhhhhhhhh    ",
   "   hhhhhhhhhhhhh    ",
   "    h..........h    ",
   "   ...(-)..(-)...   ",
   "   ......nn......   ",
   "    ....nnnn....    ",
   "     ....rr....     ",
   "     ...rwwr...     ",
   "     ...rwwr...     ",
   "      ...rr...      ",
   "       ......       ",
   "                    "],
  ], '.ea2 (eee )eee -222 nd83 r800 weee hfe4');
  e.className = "alien";
  e.hidden = true;
}

async function ignignoktNew (s=0) {
  const e = [makeSprite,makeSprite2][s](s?"ignignokt":undefined, 10, 10, [
  ["      gg     ggg    ",
   "      ggg    ggg    ",
   "      ggg    ggg    ",
   "    ggggg  ggggg    ",
   "    gggggggggggg    ",
   "    gggbggggbggg    ",
   "    ggbggggggbgg    ",
   "    gbgbbggbbgbg    ",
   "    gggggggggggg    ",
   "    gggggggggggggb  ",
   "  bgggggbbbbggggg b ",
   " b gggggggggggggg  b",
   "b  gggggggggggggg  b",
   "        b  b         ",
   "        b  b         ",
   "      bbb  bbb       "],
  ["      gg     ggg    ",
   "      ggg    ggg    ",
   "      ggg    ggg    ",
   "    ggggg  ggggg    ",
   "    gggggggggggg    ",
   "    gggbggggbggg    ",
   "    ggbggggggbgg   b",
   "    gbgbbggbbgbg   b",
   "b   gggggggggggg  b ",
   " b  gggggggggggggb  ",
   "  bgggggbbbbggggg   ",
   "   gggggggggggggg   ",
   "   gggggggggggggg   ",
   "        b  b         ",
   "        b  b         ",
   "      bbb  bbb       "]
  ], 'b00d g0d0');
  e.className = "alien";
  e.hidden = true;
}

async function alienNew (s=0) {
  const e = [makeSprite,makeSprite2][s](s?"alien":undefined, 50, 50,[
  ["   yyy   ",
   "  gyyyg  ",
   " ggdggdg ",
   " ggdggdg ",
   "  gygyg  ",
   "  g g g  ",
   " g  g  g ",
   "g   g   g"],
  ["   yyy   ",
   "  gyyyg  ",
   " gdggdgg ",
   " gdggdgg ",
   "  gygyg  ",
   " g  g  g ",
   "  g g g  ",
   "  g g g  "]
  ], "rd00 ydd0 g0d0 d444");
  e.className = "alien";
  e.hidden = true;
}

var aliens=[];

async function aliensNew (s=0) {
  switch(s) {
  case 0:
    [...Array(4)].forEach(alienNew);
    trumpNew();
    [...Array(4)].forEach(alienNew);
    ignignoktNew();
    break;
  case 1:
    alienNew(1);
    trumpNew(1);
    ignignoktNew(1);
    ["rtypebottom.png", "nasi.png"].forEach(loadImageAsSprite);
    aliens[0] = [
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'}];
    aliens[1] = [
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'}];
    aliens[2] = [
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'nasi'}];
    aliens[3] = [
      {x:0, y:0, alive:true, sprite:'trump'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},

      {x:0, y:0, alive:true, sprite:'ignignokt'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},

      {x:0, y:0, alive:true, sprite:'nasi'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'},
      {x:0, y:0, alive:true, sprite:'alien'}];
    break;
  }
}

async function missileNew (s=0) {
  [makeSprite,makeSprite2][s]("m1", 100, 0, [
  ["yyyyrr"],
  ], "ydd0 rd00");
}

async function starsNew () {
  document.body.insertAdjacentHTML("afterbegin", `<div id="stars" style="position:unset">` +
    [...Array(10)].map((_,i)=>
      `<p class="star" style="top:${100*Math.random()}%;left:${100*Math.random()}%;background-color:#eee">`)
    .join(''));
}

////

async function animateReadyMessage (state=0) {
  var e;
  switch (state) {
  case 0:
    e = $("#rp1");
    if (0 < e.style.top.atof()) {
      const x = e.style.left.atof();
      e.style.left = x-2 + "%";
      return e.style.left.atof() < -70; // return true to signal completion
    }
    break;
  case 1:
    e = sprites['rp1'];
    if (0 < e.y) {
      e.x -= 2;
      return e.x < -70; // return true to signal completion
    }
    break;
  }
}

var stars = [...Array(10)].map(_=>({x:100*Math.random(), y:100*Math.random()}));

async function animateStars (s=0) {
  switch(s) {
  case 0:
    $$(".star").forEach(e=>{
      const x = e.style.left.atof() - Math.sin(PI*e.style.top.atof()) - 1.2;
      e.style.left = (x<0 ? (e.style.top=100*Math.random()+'%',100) : x) + "%"
    });
    break;
  case 1:
    stars.forEach(({x,y},i)=>{
      const t = x - Math.sin(PI*y) - 1.2;
      stars[i].x = (x<0 ? (stars[i].y=100*Math.random(), 100) : t);
      box(stars[i].x|0, stars[i].y|0, "#ccf");
    });
    break;
  }
}

async function animateMissile (s=0, m1=$("#m1"), v) {
  switch(s) {
  case 0:
    if (0 < m1.style.top.atof()) {
      m1.style.left = (v=m1.style.left.atof()+5)+"%";
      100<v && (m1.style.top="0%");
    }
    break;
  case 1:
    if (0 < sprites['m1'].y) {
      sprites['m1'].x = (v=sprites['m1'].x+5);
      100<v && (sprites['m1'].y=0);
    }
    break;
  }
}

////

var kounter=0
var level = 0

async function animateAlien (s, e1, i) {
  switch(s) {
  case 0:
    if (e1.styles) { return }
    if (Math.random()<.1) {
      let idx = e1.getAttribute("idx") | 0;
      e1.children[idx].hidden = true;
      idx = (idx+1) % e1.children.length;
      e1.children[idx].hidden = false;
      e1.setAttribute("idx", idx);
    }

    e1.style.left = 60+30*Math.cos((i*24+kounter)/40+level*3) + "%";
    e1.style.top = 50+40*Math.sin((i*24+kounter)/(40-level*3)) + "%";
    break;
  case 1:
    break;
  }
}

var p1idx = 0;
async function animateAliens (s=0) {
  switch(s) {
  case 0:
    $$(".alien").forEach(animateAlien.bind(null, s))
    if (++p1idx%8 == 0) {
      e1 = $("#p1"); // animate player
      let idx = e1.getAttribute("idx") | 0;
      e1.children[idx].hidden = true;
      idx = (idx+1) % e1.children.length;
      e1.children[idx].hidden = false;
      e1.setAttribute("idx", idx);
    }
    break;
  case 1:
    let allDead=true;
    aliens[level%aliens.length].forEach((alien,i)=>{
      if (alien.alive) {
        const n = alien.sprite;
        if (!alien.exploding) {
          alien.x = sprites[n].x = 55+25*Math.cos((i*24+kounter)/40+level*3);
          alien.y = sprites[n].y = 40+40*Math.sin((i*24+kounter)/(40-level*3));
        } else {
          sprites[n].x = alien.x;
          sprites[n].y = alien.y;
        }
        alien.exploding
          ? renderSpriteMod(n, alien)
          : renderSprite(n);
        if (50 < alien.exploding) {
          alien.alive = false;
        } else {
          allDead=false;
        }
      }
    });
    if (allDead) {
      aliens[level%aliens.length].forEach(a=>{a.alive=true; a.exploding=0;});
      ++level;
      tune.next();
    }
    break;
  }
}

////

async function collissions (s=0) {
  let m1;
  switch (s) {
  case 0:
  m1 = $("#m1");
  $$(".alien").forEach((e1,i)=>{
    const idx = e1.getAttribute("idx") || 0;
    if (!e1.styles && (boom ||
        (Math.abs(m1.offsetLeft-e1.offsetLeft) < 50
         && Math.abs(m1.offsetTop-e1.offsetTop) < 50))) {
      e1.styles = [...e1.children[idx].children].map(e=>e.style.cssText); // save pixel locations
      soundExplode();
      i == 0 && snd.play("primitive", .1);
      i == 5 && snd.play("trump", .1);
    }
  });
  boom=0;
  break;
  case 1:
    m1=sprites['m1'];
    aliens[level%aliens.length].forEach((alien,i)=>{
      const asc = sprites[alien.sprite].center;
      if (alien.alive && !alien.exploding && (boom || (5+m1.x-alien.x-asc.x).abs()<4 && (m1.y-alien.y-asc.y).abs()<4)) {
        alien.exploding=1;
        soundExplode();
        snd.play(alien.sprite, .1);
      }
    });
    boom=0;
  break;
  }
}

async function explode () {
  const r=50;
  let allDead=true;
  $$(".alien").forEach((e1,i)=>{
    let t, outside=false;
    if (!e1.style.display) { allDead = false; }
    if (e1.styles) {
      allDead = false;
      const idx = e1.getAttribute("idx") || 0;
      [...e1.children[idx].children].forEach((e,i)=>{
        e.style.left = (t=e.style.left.atof() + Math.cos(i))+"ch";
        (t<-r || r<t) && (outside=true);
        e.style.top = (t=e.style.top.atof() + Math.sin(i))+"ch";
        (t<-r || r<t) && (outside=true);
      })
      if (outside) {
        [...e1.children[idx].children].forEach((e,i)=>{
          e.style = e1.styles[i];
          e1.style.display="none";
        });
        e1.styles = undefined;
      }
    }
  });

  if (allDead) {
    $$(".alien").forEach((e)=>e.style.display=null);
    ++level;
    tune.next();
  }
}

////


var workEnd=jiffies();

var fps = ((last=jiffies(), workeds=[], durations=[])=>
  async function fps (now=jiffies()) {
    workeds.push(workEnd-last);
    durations.push(now-last);
    last = now;
    if (51 == durations.length) { workeds.shift(); durations.shift(); }
    const worked = workeds.reduce((a,b)=>a+b);
    const elapsed = durations.reduce((a,b)=>a+b);
    tick(`${Math.round(durations.length*1000/elapsed)} ${Math.round(100*worked/elapsed)}%`);
  }
)();

///////

function loadImageAsSprite (fn) {
  const img = new Image();
  img.src=fn;
  img.onload = r=>{
    const cnvs = document.createElement('canvas');
    cnvs.width = img.width;
    cnvs.height = img.height;
    const ctx = cnvs.getContext('2d');
    ctx.drawImage(img, 0, 0);
    makeSprite3(fn.split('.')[0], img.width, img.height,
        ctx.getImageData(0, 0, img.width, img.height).data);
  }
}

function renderBottom () {
  const s = sprites['rtypebottom'];
  if (!s) { return; }
  const k = (kounter/8)%(s.w+0);
  const r = s.w+0-k;
  s.x=-k; s.y=100-(s.h+0);
  renderSprite('rtypebottom');
  if (r<100) {
    s.x=r;
    renderSprite('rtypebottom');
  }

  c2d.transform(1,0,0,-1,0,0);

  s.x=-k; s.y=-s.h;
  renderSprite('rtypebottom');
  if (r<100) {
    s.x=r;
    renderSprite('rtypebottom');
  }

  c2d.transform(1,0,0,-1,0,0);
}

const clear = ()=>{
  const w=body.clientWidth
  const h=body.clientHeight;
  if (canvas.bodyWidth!=w || canvas.bodyHeight != h) {
    canvas.bodyWidth = w;
    canvas.bodyHeight = h;
    const s = max(min((w*.01|0)*100, (h*.01|0)*100), 100);
    if (canvas.width != s) {
      canvas.width = canvas.height = s;
      canvas.pixelSize = s*.01|0;
      canvas.pixelWidth = max(canvas.pixelSize-1, 1);
    }
  }
  c2d.clearRect(0, 0, canvas.width, canvas.height);
}

const box = (x, y, c, s=canvas.pixelSize, w=canvas.pixelWidth)=>{
  c2d.fillStyle = c;
  c2d.fillRect(x*s, y*s, w, w);
}

////

var touchLastY, touchY;

async function handlersGame () {

  touchY = body.clientHeight/2;
  const p1 = $("#p1");

  body.addEventListener("touchstart", ()=>{
    touchLastY = event.changedTouches.item(0).clientY;
  });

  const shipSlide = (delta) => {
    touchY += delta;
    touchY = touchY<0
      ? 0
      : body.clientHeight < touchY
        ? body.clientHeight
        : touchY;
    p1.style.top = Math.floor(touchY/10) * 10 + "px";
  }

  body.addEventListener("touchmove", ()=>{
    const y = event.changedTouches.item(0).clientY;
    shipSlide(y-touchLastY);
    touchLastY = y;
  });

  body.onmousemove = _=>{
    p1.style.top=Math.floor(
      (event.changedTouches?.item(0)||event).clientY/10
    ) * 10 + "px";
  };

  const m1 = $("#m1");
  const fire = _=>{
    m1.style.top = p1.style.top;
    m1.style.left = "5%";
    event.preventDefault();
    //event.stopPropagation();
  };

  body.onmousedown = fire;
  body.addEventListener("touchend", fire);
  body.onkeydown = ()=>{
    switch (event.key) {
    case "ArrowUp": shipSlide(-10); break;
    case "ArrowDown": shipSlide(10); break;
    case "Escape": case "Backspace": power=power?0:snd.wac.resume(),gameDomLoop(),snd.wac.suspend(),1; break;
    case "*": boom=1;break;
    default: fire(); break;
    }
  }
}

var boom=0;
var power=1;
var state=0;

const gameStateMachine={
 0: ()=>animateAliens()
    .then(animateMissile)
    .then(animateReadyMessage)
    .then((isdone)=>(snd.wac.resume(), state=isdone?1:0)),
 1: ()=>(
    $$(".alien").forEach(e=>e.hidden=0),
    $("#rp1").hidden=1,
    state=2),
 2: ()=>animateMissile(0)
    .then(collissions)
    .then(explode)
    .then(animateAliens)
};

async function gameDomLoop (t) {
  fps()
  .then(animateStars)
  .then(()=>kounter+=1.1)
  .then(gameStateMachine[state])
  //.then(()=>new Promise(r=>setTimeout(r,50)))
  //.then(()=>{workEnd=jiffies(); power&&setTimeout(gameDomLoop, 0);})
  .then(()=>(workEnd=jiffies(),power&&requestAnimationFrame(gameDomLoop)))
  .catch(l)
}

const gameDom = async ()=>{
  rp1New()
  .then(playerNew)
  .then(aliensNew)
  .then(missileNew)
  .then(starsNew)
  .then(handlersGame)
  .then(sfx)
  .then(_=>requestIdleCallback(gameDomLoop))
  .catch(l)
}

////

//var mouse = {x:0, y:0};

var gameCanvas = async () => {
  switch (state) {
  case 0:
    body.onkeydown = ()=>{
      switch (event.key) { case "Escape": case "Backspace": power=!power; break; }
    }
    await rp1New(1)
      .then(()=>playerNew(1))
      .then(()=>aliensNew(1))
      .then(()=>missileNew(1));
    body.addEventListener("touchstart", ()=>{
      touchLastY = event.changedTouches.item(0).clientY;
    });
    var touchY = 50*10;
    const shipSlide = (delta) => {
      if (touchY===undefined) { touchY=sprites['p1'].y*10; return; }
      touchY += delta;
      touchY = touchY<0
        ? 0
        : 900 < touchY
          ? 900
          : touchY;
        sprites['p1'].y = touchY/10|0 ;
    }
    body.addEventListener("touchmove", ()=>{
      const y = event.changedTouches.item(0).clientY;
      shipSlide(y-touchLastY);
      touchLastY = y;
    });
    const fire = _=>{
      sprites['m1'].y = sprites['p1'].y+4;
      sprites['m1'].x = 5;
      event.preventDefault();
      //event.stopPropagation();
    };
    body.onmousedown = fire;
    body.addEventListener("touchend", fire);
    body.onkeydown = ()=>{
      switch (event.key) {
      case "ArrowUp": shipSlide(-10); break;
      case "ArrowDown": shipSlide(10); break;
      case "Escape": case "Backspace": power=power?0:snd.wac.resume(),gameCanvas(),snd.wac.suspend(),1; break;
      case "*": boom=1;break;
      default: fire(); break;
      }
    }
/*
    canvas.onmousemove = _=>{
      s = Math.min( (canvas.clientWidth/100)|0, (canvas.clientHeight/100)|0 );
      mouse.x = event.x/s|0;
      mouse.y = event.y/s|0;
    };
*/
    body.onmousemove = _=>{
      sprites['p1'].y=(100*
        (event.changedTouches?.item(0)||event).clientY
      /body.clientHeight).floor();
    };
    state=1;
    gameCanvas();
    sfx()
    break;
  case 1:
    fps()
    .then(clear)
    .then(()=>kounter+=19.1)
    .then(()=>animateMissile(1))
    .then(()=>animateStars(1))
    .then(renderBottom)
    .then(()=>renderSprites(['m1','p1','rp1']))
    .then(()=>animateReadyMessage(1))
    .then((isdone)=>(snd.wac.resume(), isdone&&(state=2)))
    .then(()=>(workEnd=jiffies(), power&&requestAnimationFrame(gameCanvas)))
    break;
  case 2:
    fps()
    .then(clear)
    .then(()=>kounter+=1.1)
    .then(()=>animateStars(1))
    .then(renderBottom)
    .then(()=>animateMissile(1))
    .then(()=>collissions(1))
    .then(()=>animateAliens(1))
    .then(()=>renderSprites(['m1','p1']))
    .then(()=>(workEnd=jiffies(), power&&requestAnimationFrame(gameCanvas)))
    break;
  }
}

////

let isPlaying=0, song;

async function jukebox (t) {
  fps()
  .then(animateStars)
  .then(()=>{
    isPlaying ||= snd.notes(song, ()=>isPlaying=0);
    requestAnimationFrame(jukebox);
    workEnd = jiffies();
  })
  .catch(l)
}

async function handlersJukebox () {
  [...$("#pb").children].map((e,i)=>e.hidden=i==0+('suspended'==snd.wac.state));
  body.onkeydown = body.onmousedown = ()=>{
    [...$("#pb").children].map((e,i)=>e.hidden=i==0+('suspended'!=snd.wac.state));
    snd.wac.state=="suspended" ? snd.wac.resume() : snd.wac.suspend();
  };
}

const jukeboxStart = async()=> {
  starsNew()
  .then(pbNew)
  .then(handlersJukebox)
  .then(jukebox)
  .catch(l);
};

////

async function gameCabinet () {
  switch (state) { case 0:
    body.insertAdjacentHTML("afterbegin", '<img src="pongCabinetTop.png">');
    canvas.width = canvas.height = 100;
    canvas.style.left = "188px";
    canvas.style.top = "168px";
    body.onkeydown = ()=>{
      switch (event.key) { case "Escape": case "Backspace": (power=!power) && gameCabinet(); break; }
    }
    state=1;
    requestAnimationFrame(gameCabinet);
  break; case 1:
    //clear();
    [...Array(100)].forEach(_=>
      box(rnd(100),
      rnd(100),
      '#'+('00'+(Math.random()*16*16*16).toFixed()).slice(-3), 1, 2));
    [...Array(20)].forEach((_,i)=>box(
      50+(kounter+i*.17).cos()*50,
      50+50*(kounter*.9+i*.19).sin(),
      "#0f0", 1, 2, kounter+=1*i.sin()));
    power && requestAnimationFrame(gameCabinet);
  break; }
}

////

Ok(decodeURI(location.search).slice(1))
((queryString)=>(
  {'1':gameCabinet, '2':gameCanvas, '':gameDom}[(song=queryString)]||jukeboxStart)())

</script></body></html>
